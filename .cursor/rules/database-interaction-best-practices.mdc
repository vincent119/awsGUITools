---
description: 在後端 Go 程式碼中與資料庫互動時的完整最佳實務規範。
globs: **/db/**/*.go
alwaysApply: true
---

# DataBase

在與資料庫互動時，請遵守以下原則與最佳實務。

[總則]

- 以「正確性與資料一致性」優先，其次才是效能與便利性。
- 所有與資料庫互動的程式碼應保持可測試、可維護、易讀。
- 嚴格避免將 SQL、連線、交易邏輯散落在各層，優先集中於 repository 或 data access layer。

[連線與資源管理]

- 使用資料庫連線池（例如 Go 的 database/sql 預設連線池），避免自行管理單一長連線。
- 適當設定最大開啟連線數、最大閒置連線數與連線存活時間，以避免資源耗盡或連線被 DB 端關閉。
- 所有取得的 `Rows`、`Stmt`、`Tx`、`Conn` 必須在使用完畢後呼叫 `Close()`，避免資源洩漏。
- 嚴禁在熱路徑中重複建立新的資料庫連線實例，應在啟動時建立並注入重用。

[查詢與命令執行]

- 使用預備語句（prepared statements）或具名參數（視 driver 而定），以防範 SQL 注入攻擊。
- 嚴禁使用字串拼接方式組 SQL，特別是含有使用者輸入時。
- 對查詢結果進行嚴謹的型別掃描（Scan），確保欄位與型別對應正確。
- 僅在需要時使用 `SELECT *`，一般情況下應明確列出欄位名稱以提升可維護性與效能。
- 對可能返回大量資料的查詢，需評估是否需要分頁（pagination）或限制結果集大小。

[交易（Transaction）管理]

- 使用顯式交易（`BEGIN` / `COMMIT` / `ROLLBACK` 或 `db.BeginTx`）來保證多步驟資料操作的一致性。
- 交易邏輯應封裝在單一函式或方法中，以確保事務邏輯簡潔清楚。
- 使用 `defer` 保證在錯誤或非預期情況下會執行 `Rollback()`，避免交易懸掛。
- 嚴禁在交易內執行不必要的耗時操作（例如外部 HTTP 呼叫），以縮短交易時間與鎖定範圍。
- 清楚區分讀取操作與寫入操作，讀多寫少的情境可考慮讀寫分離架構（如使用 replica）。

[Context 與 Timeout]

- 所有資料庫操作應接收並使用 `context.Context`，支援請求取消與 timeout。
- 為重要或可能耗時的查詢設置合理的 timeout，避免因下游 DB 問題導致整體服務掛死。
- 禁止忽略 context；避免在 DB 操作中使用 `context.Background()` 直接取代上游 context。

[錯誤處理與重試]

- 對資料庫錯誤進行有意義的分類與處理（例如：不存在、唯一性衝突、連線錯誤、timeout 等）。
- 嚴禁直接吞掉錯誤或回傳無意義的錯誤訊息；錯誤訊息應包含足夠資訊方便除錯，但避免洩露敏感資料。
- 在可重試的錯誤（例如暫時性連線問題）情境下，可考慮實作有上限的重試機制，並搭配退避策略（backoff）。
- 對於商業邏輯錯誤與系統錯誤應區分對待，避免將所有錯誤一律視為 500 類型。

[ORM 與查詢構建]

- 在查詢與資料模型複雜度較高時，可以考慮使用 ORM 或 query builder（例如 GORM、sqlx、squirrel）。
- 使用 ORM 時，要理解其產生 SQL 的行為與效能特性，避免隱性 N+1 查詢與不必要的 JOIN。
- 若採用 ORM，仍應保留對 raw SQL 的支持，以應付需要精準控制查詢的場景。
- 對於關鍵熱點查詢，建議檢視實際執行的 SQL、使用 EXPLAIN / EXPLAIN ANALYZE 進行效能診斷。

[交易隔離級別與鎖]

- 明確標註交易隔離級別（PostgreSQL 預設 `read committed`、MySQL 常見 `repeatable read`）；一致性需求高時顯式設定。
- 避免長交易；外部 I/O 移出交易；必要時使用樂觀鎖/版本欄位並結合重試。

[重試與冪等策略]

- 僅對可安全重試的操作實施重試；增刪改以 idempotency key 或唯一性約束確保冪等。
- 採指數退避與最大嘗試次數；對序列化衝突（如 PostgreSQL `serialization_failure`）可重試。

[連線池監控與告警]

- 監控 `in_use`, `idle`, `wait_count`, `wait_duration` 指標；wait 持續上升或超過門檻時告警。
- 定期檢視 pool 設定與查詢計劃，避免連線枯竭或過度閒置。

[索引與查詢策略]

- 優先建立選擇性高的索引；複合索引遵循「等值在前、範圍在後」。
- 對低選擇性欄位避免單列索引；必要時使用部分/條件索引（PostgreSQL）。

[資料一致性與設計]

- 遵循正規化原則設計資料表，必要時可為效能進行適度反正規化，並清楚紀錄理由。
- 對於跨服務或跨系統的資料一致性需求，考慮使用：
  - 事件溝通（event-driven）
  - Outbox pattern
  - SAGA pattern 或補償交易
- 對於關鍵欄位（例如金額、狀態）要特別注意更新流程，避免 race condition 或不一致狀態。

[安全性]

- 禁止在 logs 中輸出敏感資料（例如密碼、憑證、身份證號碼、信用卡完整號碼）。
- 使用最小權限原則（least privilege）：DB 帳號只賦予必要權限。
- 儲存機密資訊（例如 DB 密碼、連線字串）時，應使用安全的設定管理機制（例如環境變數、密鑰管理服務），而非硬編碼在程式碼中。

[測試與可測性]

- 為資料庫存取層撰寫單元測試與整合測試。
- 對關鍵查詢、交易與錯誤情境撰寫測試案例，確保：
  - 正常流程
  - 邊界條件
  - 錯誤路徑
- 儘可能設計 repository 介面以便於 mocking 與替換實作，提高可測性。
- 在 CI 中可使用 ephemeral DB（例如 Docker 啟動的 PostgreSQL/MySQL）進行整合測試。

[日誌與監控]

- 對重要的 DB 操作，需記錄關鍵 log（但不包含敏感內容），例如：查詢名稱、耗時、錯誤類型。
- 對 DB 操作的 latency、錯誤率、連線池狀態（例如 in-use/idle 數量）進行監控。
- 必要時加入 tracing（例如 OpenTelemetry）以追蹤跨服務與 DB 的 end-to-end latency。
